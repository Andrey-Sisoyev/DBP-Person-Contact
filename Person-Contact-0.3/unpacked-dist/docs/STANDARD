-- Copyright (C) 2010 Andrejs Sisojevs <andrejs.sisojevs@nextmail.ru>
-- 
-- All rights reserved.
-- 
-- For information about license see COPYING file in the root directory of current nominal package

DB PACKAGING STANDARD v0.3
Standard: DBP-std-0.3
------------------------------

You may obtain a copy of DB package template (together withthis standard) 
from network location:
    http://github.com/Andrey-Sisoyev/DBP-tpl


Aims of the DB packaging standard
-------------------------------------------------------------------------------
This standard is a specification used in the base of template for DB packages. 
Originally template was made to provide way of constructing a DB by way
of composing a set of such DB packages. 
The composing is made easy: install first (usually most general and 
independent) package using script "db_inst.sh" with "new" command for DB, 
for application and for package. This will create
a new DB, schema there for your application and install a package in the schema. 
In all subsequent (probably dependent) 
packages run "db_inst.sh" with "existing" commands - this will 
build up more and more DB objects on top of already initialized, 
shaping your DB. Wether to choose new database or existent for your new 
application is up to you - if you need multiple applications to 
be able to share and/or one to easily access some data of another - 
then it's best to put applications in dedicated schemas under one database. 
If applications are to be independent and/or portablable away one from another, 
then it's best to place them in different DBs.

Obvious weaknesses of this packaging system:
1. It won't seek dependencies of DB packages. This you must do on your own. 
   For this purpose use "Depends-On" field in the PKG-INFO file.
2. DB, application, package insalled based on one version of this STANDARD
   can't be managed by packagers (for probably same data structures) based on
   other version of STANDARD. F.e., if you installed package "Language-0.7" 
   using "DBP-std-0.1" STANDARD, then you can't safely remove this 
   installment using package "Language-0.7" made with "DBP-std-0.1" STANDARD 
   in the base.
   By the way, "Language-0.7" installment can't be uninstalled by 
   "Language-0.8" package even if they are based on the same STANDARD.

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------


Standard DB structure template
-------------------------------------------------------------------------------
The scripts set is made to initialize DB using a STADARD, which includes 
a) naming convetion
b) specific use of tablespaces
c) specific set of DB objects for an application
d) storage and management of the metadata of installed DBs, applications 
   and packages
It is extendible for specific applications, but for simpliest general case is 
considered to be such. Any changes made to initialization/drop scripts of DB, 
scheama (application) or metadata (describing installed DBs, applications 
and packages) MUST lead to branching to the new version of this STANDARD, 
and version of the template - the value of field "Template" in the beginning 
of this file must be changed.

Variables:
    <<$db_name$>> 
        A variable containing DB name '[_a-z][_a-z0-9]*'.
        One DB may contain multuple (possibly) interconnected applications.
        (use no uppercase !!!)
    <<$app_name$>> 
        An application name '[_a-z][_a-z0-9]*'.
        (use no uppercase !!!)
    <<$PGDATA$>>
        OS environmetntal variable PGDATA. It is installe
        (for example: "/var/lib/postgres/data/")
    <<$pkg.name$>>
        Name of current package '[_a-zA-Z0-9][-_a-zA-Z0-9.]'.
        Value in the field "Name" in file PKG-INFO.
    <<$pkg.name_p$>>
        <<$pkg.name$>> converted to satisfy '[_a-z][_a-z0-9]*' pattern
        (Lowercased, '-' -> '_', '.' -> '_')
    <<$pkg.ver$>>  
        Version of current package '[_a-zA-Z0-9][-_a-zA-Z0-9.]'.
        Value in the field "Version" in file PKG-INFO.
    <<$pkg.ver_p$>>
        <<$pkg.ver$>> converted to satisfy '[_a-z][_a-z0-9]*' pattern
        (Lowercased, '-' -> '_', '.' -> '_')
    <<$pkg.std_ver$>>
        Name and version of standard.
        value in the field "Standard" in the beginning of this file

For any application there are following layers of DB objects:
1. Database top layer (db.drop.sql, db.init.sql):
     1.1. Data base named '<<$db_name$>>', with support of language "plpgsql"
     1.2. Default tablespace named 'tabsp_<<$db_name$>>_dflt'
          (Tablespace location directory:
          '<<$PGDATA$>>pg_tblspc/<<$db_name$>>/dafault.data')

     1.3. User named 'user_<<$db_name$>>_owner':
             * with initial password = 'db_owner_password'
             * superuser of this DB
          (Security concern: don't forget to change password)
     1.4. Function 'version_of_standard_based_on_which_the_db_was_created()'
          Which returns <<$pkg.std_ver$>> using which the DB was created.
     1.5. Schema "comn_funs" for library of general purpose functions 
          for public use.
     1.6. Table 'public.dbp_applications' containing list of applications 
          installed in this database. Fields: 
             * 'application_name' (varchar PRIMARY KEY)
             * 'dbp_standard_version' (varchar) - name and version 
               of the STANDARD, based on which was the package, 
               that registered the application.
          Functions and table are allowed to be used 
          only by DB/app owner roles.
     1.7. Table for information about roles, tablespaces and/or 
          whatever else clusterwide objects (whose types are enumerated 
          by "t_clusterwide_obj_types" type) are there created 
          for use ONLY with this database/application.
          TABLE public.dbp__db_dependant_clusterwide_objs (
                  cwobj_name       varchar NOT NULL
                , cwobj_type       t_clusterwide_obj_types NOT NULL
                , cwobj_additional_data_1 varchar CHECK (cwobj_additional_data_1 IS NOT NULL OR cwobj_type != 'tablespace')
                , application_name varchar REFERENCING public.dbp_applications(application_name)
                , drop_it_by_cascade_when_dropping_db  boolean NOT NULL
                , drop_it_by_cascade_when_dropping_app boolean     NULL CHECK (drop_it_by_cascade_when_dropping_app IS NOT NULL OR application_name IS NULL)
                , PRIMARY KEY(cwobj_name, cwobj_type)
                )
          And 2 functions to register and unregister object there:
             * public.register_cwobj_tobe_dependant_on_current_dbapp(...)
             * public.unregister_cwobj_thatwere_dependant_on_current_dbapp(...)
          Functions and table are allowed to be used 
          only by DB/app owner roles.
2. Application outer layer (schema.drop.sql, schema.init.sql):
     2.1. User named 'user_db<<$db_name$>>_app<<$app_name$>>_owner':
             * with initial password = 'user_db<<$db_name$>>_app<<$app_name$>>_owner'
             * superuser of schema 'sch_<<$app_name$>>' (2.6.)
     2.2. User named 'user_db<<$db_name$>>_app<<$app_name$>>_data_admin' 
             * with initial password = 'user_db<<$db_name$>>_app<<$app_name$>>_data_admin')
     2.3. User named 'user_db<<$db_name$>>_app<<$app_name$>>_data_reader'
             * with initial password = 'user_db<<$db_name$>>_app<<$app_name$>>_data_reader')
     (Security concern: don't forget to change passwords)

     2.4. Tablespace named 'tabsp_<<$db_name$>>_<<$app_name$>>'
     2.5. Tablespace named 'tabsp_<<$db_name$>>_<<$app_name$>>_idxs' 
          (for indexes only)
     (Both tablespaces be located in the directory 
     '<<$PGDATA$>>/pg_tblspc/<<$db_name$>>/<<$app_name$>>')

     2.6. Entry in the table 
                  public.dbp_applications { 
                    application_name     = <<$app_name$>>
                  , dbp_standard_version = <<$pkg.std_ver$>>
                  }
     2.7. Schema 'sch_<<$app_name$>>' with owner 'user_db<<$db_name$>>_app<<$app_name$>>_owner'
     2.8. Table 'sch_<<$app_name$>>.dbp_packages' containing list of packages 
          installed in this application. Fields: 
             * 'package_name'
             * 'package_version'
             * 'dbp_standard_version' - name and version of the STANDARD, based
               on which was the package, that registered the application.
3. Application inner level or package level (structure, functions 
   and data init/drop .sql): 
     3.1. Entry in the table 
                  sch_<<$app_name$>>.dbp_packages { 
                    package_name         = <<$pkg.name$>>
                  , package_version      = <<$pkg.ver$>>
                  , dbp_standard_version = <<$pkg.std_ver$>>
                  }
     3.*. Schema objects, depending on package content: tables, sequences, 
          indexes, triggers, grants, functions, etc.
     3.*. inserts, updates.

There must be a package-specific test script, that would test DB objects 
persistance and functionality IMMEDIATELY after removal-creation scripts cycle.
This test script doesn't have to guarantee to leave DB unchanged except for the
case IMMEDIATELY after removal-creation scripts cycle. Running test script 
in DB filled with user data is not to be guaranteed safe. However, package 
author may describe this safetiness in the PKG-INFO file - in the boolean
field "Safe-to-test-with-user-data", which by default is FALSE.

The packager infrastructure must provide following public informative services:
1. List all applications installed in DB <<$db_name$>>.
2. List all packages     installed in DB <<$db_name$>>,
   in application <<$app_name$>>.
And these nonpublic (for inner use) informative services:
3. Check if a DB <<$db_name$>> is installed.
4. Check if an application <<$app_name$>> in the DB <<$db_name$>> is 
   installed.
5. Check if a package <<$pkg.name$>> in an application <<$app_name$>> 
   in the DB <<$db_name$>> is installed.
6. Check if a package <<$pkg.name$>>, that is installed in 
   an application <<$app_name$>> in the DB <<$db_name$>>, 
   has version <<$pkg.ver$>>.
7. Check if a DB <<$db_name$>> is installed using STANDARD <<$pkg.std_ver$>>.
8. Check if an application <<$app_name$>>, that is installed 
   in the DB <<$db_name$>>, is installed using STANDARD <<$pkg.std_ver$>>.
9. Check if a package <<$pkg.name$>>, that is installed in 
   an application <<$app_name$>> in the DB <<$db_name$>>, 
   is installed using STANDARD <<$pkg.std_ver$>>.

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
